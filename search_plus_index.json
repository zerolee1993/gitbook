{"./":{"url":"./","title":"大纲","keywords":"","body":"【编程技巧】 《代码大全》 【编程语言】 《Java 核心技术（卷 1）》 《Head First Java》 《Spring in Action》 《Spring Boot 实战》 【操作系统】 《鸟哥的 Linux 私房菜》 【网络协议】 MDN：HTTP 文档 了解 HTTP 头、HTTP 请求方法、HTTP 返回码 了解 Cookie、缓存、会话、连接管理 【数据库设计】 Imooc：数据库设计的那些事 《MySQL 必知必会》 MySQL 官方文档 【字符编码】 Blog：关于字符编码，你所需要知道的) Blog：The history of Character Encoding Wiki：Character encoding GitHub：Awesome Unicode GitHub：Awesome Code Points 【编程工具】 Intellij IDEA Blog：Intellij IDEA 中文教程 Git Blog：Pro Git 第二版 Blog：猴子都能懂的 Git 入门 GitHub：GitHub and Git 图文教程 Blog：Git 图文教程及详解 Chrome Blog：超完整的 Chrome 浏览器客户端调试大全 powered by Gitbook修订时间： 2023-04-03 14:53:24 "},"markdown/00-homework/pref-task.html":{"url":"markdown/00-homework/pref-task.html","title":"项目性能优化 TODO","keywords":"","body":"项目性能测试报告 01-测试目的 主要是让开发者对hero_mall项目的性能负载和容量有个准确的认知。同时，协助技术管理者更好的管 理业务系统性能质量，科学评估业务系统的负荷，拒绝盲目上线。 02-测试工具 03-测试环境 04-测试场景 05-核心接口的测试结果 06-测试结论 hero_web性能测试是针对重点功能，单机单节点服务进行压测，可以看到各个接口容量。本测试供给大 家作为参考，如有不足或偏差，请指正！如果对性能有其他需求，可以进行集群扩容。例如:3节点、10 节点、100节点... 地址：https://open2.hero.comvipcourse/order/{orderNo}1 powered by Gitbook修订时间： 2022-09-11 00:15:03 "},"markdown/00-homework/jvm-task.html":{"url":"markdown/00-homework/jvm-task.html","title":"JVM 虚拟机 TODO","keywords":"","body":"题目 01 请你用自己的语言介绍 Java 运行时数据区（内存区域） 堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存 堆 在虚拟机启动时建立，用于存放 Java 对象、数组与运行时常量 所有线程共享 虚拟机管理最大的，也是垃圾回收的主要区域 2. 为什么堆内存要分年轻代和老年代？ 题目 02 描述一个 Java 对象的生命周期 解释一个对象的创建过程 解释一个对象的内存分配 解释一个对象的销毁过程 对象的 2 种访问方式是什么？ 为什么需要内存担保？ 题目 03 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？ ParNew 收集器 ParallelScavenge 收集器 ParallelOld 收集器 CMS 收集器 G1 收集器 powered by Gitbook修订时间： 2022-09-22 16:25:38 "},"markdown/01-java/pref.html":{"url":"markdown/01-java/pref.html","title":"项目性能优化","keywords":"","body":"powered by Gitbook修订时间： 2022-09-10 23:42:17 "},"markdown/01-java/jvm-01.html":{"url":"markdown/01-java/jvm-01.html","title":"1.JVM 基本常识","keywords":"","body":"1.1 什么是 JVM? 广义上指的是一种规范 狭义上的是JDK中的JVM虚拟机 JVM 是由各个厂商来实现，比如hotspot 1.2 Java 技术体系 Java程序设计语言 Java类库API 来自商业机构和开源社区的第三方Java类库(Google\\Apached等) Java虚拟机，各种硬件平台上的Java虚拟机实现 1.3 JVM 架构图 1.4 Java 和 JVM 的关系 JVM是宿主，Java 开发的程序则寄生在宿主上 Java，Kotlin、Clojure、JRuby、Groovy等运行于Java虚拟机上的编程语言及其相关的程序都属于Java技术体系中的一员 powered by Gitbook修订时间： 2022-12-04 20:49:55 "},"markdown/01-java/jvm-02.html":{"url":"markdown/01-java/jvm-02.html","title":"2.类加载子系统","keywords":"","body":"2.1 类加载的时机 遇到 new、getstatic、putstatic 和 invokestatic 这四条指令时，如果对应的类没有初始化，则要对对应的类先进行初始化 public class Student{ private static int age ; public static void method(){} } //Student.age //Student.method(); //new Student(); 使用 java.lang.reflect 包方法时对类进行反射调用的时候 Class c = Class.forname(\"com.hero.Student\"); 初始化一个类的时候发现其父类还没初始化，要先初始化其父类 当虚拟机开始启动时，用户需要指定一个主类(main)，虚拟机会先执行这个主类的初始化 2.2 类加载的过程 类加载步骤 全限定名称>>>二进制字节流加载 class 文件 字节流的静态数据结构>>>方法区的运行时数据结构 创建字节码 Class 对象 类加载途径 jar/war jsp 生成的 class 数据库中的二进制字节流 网络中的二进制字节流 动态代理生成的二进制字节流 类的生命周期 2.3 类加载器 启动类加载器 Bootstrap ClassLoader 负责加载 JAVA_HOME\\lib 目录中的，或通过 -Xbootclasspath 参数指定路径中的，且被虚拟机认可(按文件名识别，如 rt.jar)的类 由 C++ 实现，不是 ClassLoader 的子类 扩展类加载器 Extension ClassLoader 负责加载 JAVA_HOME\\lib\\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库 应用程序类加载器 Application ClassLoader 负责加载用户路径(classpath)上的类库 自定义类加载器 User ClassLoader 加载应用程序之外的类文件 在汽车行驶的时候，为汽车更换轮子 案例：JRebel 自定义类加载器案例 新建一个 User.java 类 public class User { public void print() { System.out.println(\"****User****\"); } } 将类 copy 到目录 /Users/lishaofei/Downloads 编译类： javac User.java 自定义类加载器，继承 ClassLoader，重写 findClass() 方法，调用 defineClass() 方法 package com.zero.snippet.jvm; import java.io.*; import java.lang.reflect.Method; /** * 自定义类加载器案例 * * @author lishaofei * @date 2022/9/12 11:31 */ public class MyCustomClassLoader extends ClassLoader { private final String classpath; public MyCustomClassLoader(String classpath) { this.classpath = classpath; } public static void main(String[] args) throws Exception { //自定义类加载器的加载路径(事先在该目录使用同版本 jdk 编译一个 class 类，参考 model.User) MyCustomClassLoader myCustomClassLoader = new MyCustomClassLoader(\"/Users/lishaofei/Downloads\"); // 类全限定名称 Class c = myCustomClassLoader.loadClass(\"User\"); if (c != null) { // 创建对象 Object obj = c.newInstance(); // 获取对象的指定方法 Method method = c.getMethod(\"print\", (Class[]) null); // 执行方法 method.invoke(obj); // 打印该类的类加载器 System.out.println(c.getClassLoader().toString()); // 打印内容：com.zero.snippet.jvm.MyCustomClassLoader@2f2c9b19 } } @Override protected Class findClass(String name) throws ClassNotFoundException { try { // 输入流，通过类的全限定名称加载文件到字节数组 // 将文件目录中的 class 文件，以字节码流输入内存 byte[] classDate = getData(name); if (classDate != null) { //defineClass方法将字节数组数据 转为 字节码对象 return defineClass(name, classDate, 0, classDate.length); } } catch (IOException e) { e.printStackTrace(); } return super.findClass(name); } //加载类的字节码数据 private byte[] getData(String className) throws IOException { String path = classpath + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; try (InputStream in = new FileInputStream(path); ByteArrayOutputStream out = new ByteArrayOutputStream()) { byte[] buffer = new byte[2048]; int len; while ((len = in.read(buffer)) != -1) { out.write(buffer, 0, len); } return out.toByteArray(); } catch (FileNotFoundException e) { e.printStackTrace(); } return null; } } 执行自定义类加载器的 main 方法 输出结果如下 ****User**** com.zero.snippet.jvm.MyCustomClassLoader@3b81a1bc 2.4 类加载的机制 自底向上：检查类是否被加载，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次 自定向下：执行加载，由上层来逐层尝试加载此类，防篡改 powered by Gitbook修订时间： 2022-10-03 09:35:51 "},"markdown/01-java/jvm-03.html":{"url":"markdown/01-java/jvm-03.html","title":"3.运行时数据区","keywords":"","body":"3.1 整体构成 程序执行区域、线程独享、无需垃圾回收：虚拟机栈、本地方法栈、程序计数器 数据存储区域、线程共享、需要垃圾回收：堆、方法区、字符传常量池 ​ 3.2 虚拟机栈 每个线程会创建私有的栈内存，生命周期与线程相同 每个方法执行时会创建一个栈帧，每个方法从开始调用到执行完成，都对应着一个栈帧入栈出栈的过程 栈帧（Stack Frame）是用于支持 JVM 进行方法执行的数据结构，存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等 虚拟机栈异常及案例 线程分配容量超过 JVM 允许最大容量，Xss 默认为 1M，则会抛出 StackOverflowError public class StackError { private static int index = 1; public static void main(String[] args) { StackError mock = new StackError(); try { mock.call(); } catch (Throwable e) { System.out.println(\"Stack Deep: \" + index); e.printStackTrace(); } } public void call() { index++; call(); } } 若栈动态拓展，尝试拓展时无法申请到足够内存，则会抛出 OOM 若在创建新的线程时，没有足够内存，则会抛出 OOM(不一定) public class StackOOMError { public static void main(String[] args) { for (int i = 0; i 3.3 本地方法栈 与虚拟机栈相似，为 Native 方法服务 为什么需要本地方法？ Java是一门高级语言，不直接与操作系统资源、系统硬件打交道 通过 native 方法调用 cpp 编写的接口，与 OS 交互 3.4 程序计数器 也叫 PC 寄存器，当前线程所执行的字节码指令的行号指示器 分支，循环，跳转，异常处理，线程恢复等都需要依赖这个计数器来完成 存在的意义即保证线程切换(系统上下文切换)后能恢复到正确的执行位置 线程执行 Java 方法时记录正在执行的虚拟机字节码指令地址，执行 Native 方法时值为空 唯一没有 OOM 异常情况的区域 3.5 堆 在JVM启动时创建内存区域去实现对象、数组与运行时常量的内存分配 虚拟机管理最大的，也是垃圾回收的主要内存区域 内存划分的理论依据 弱分代假说：绝大多数对象都是朝生夕灭 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡 跨带引用假说：年轻代和老年代的引用关系很少 内存模型变迁历史 JDK1.6 JDK1.7 Young 年轻区: 主要保存年轻对象，分为三部分，Eden区、两个Survivor区 Tenured 年老区: 主要保存年长对象，当对象在Young复制转移一定的次数后，对象就会被转移到Tenured区 Perm 永久区: 主要保存class、method、filed对象，这部份的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到OOM：PermGen space 的错误 Virtual区: 最大内存和初始内存的差值，就是Virtual区 JDK1.8 由2部分组成，新生代(Eden + 2*Survivor ) + 年老代(OldGen ) JDK1.8中变化最大是，的Perm永久区用Metaspace进行了替换 注意:Metaspace所占用的内存空间不是在虚拟机内部，而是在本地内存空间中。区别于 JDK1.7 JDK1.9 取消新生代、老年代的物理划分 将堆划分为若干个区域(Region)，这些区域中包含了有逻辑上的新生代、老年代区域 每个 Region 默认为 1M 内存可视化案例 启动一个 java 程序 public class HeapObserve { public static void main(String[] args) { System.out.println(\"------start------\"); try { Thread.sleep(1000 * 60 * 60); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"-------end-------\"); } } 使用 VisualVM 查看对应进程的内存分布 JDK1.8 JDK11 命令行查看 # JDK1.8 jmap -heap --pid 79632 # JDK11 jhsdb jmap --heap --pid 79632 3.6 方法区 实现方式变迁历史 永久代与元空间的区别 JDK1.8之前使用的方法区实现是永久代，JDK1.8及以后使用的方法区实现是元空间。 存储位置不同:永久代所使用的内存区域是JVM进程所使用的区域，它的大小受整个JVM的大小所限制。元空间所使用的内存区域是物理内存区域。那么元空间的使用大小只会受物理内存大小的限制。 存储内容不同:永久代存储的信息基本上就是上面方法区存储内容中的数据。元空间只存储类的元信息，而静态变量和运行时常量池都挪到堆中。 为何使用元空间代替永久代 字符串存在永久代中，容易出现性能问题和永久代内存溢出。 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低 Oracle 计划将 HotSpot 与 JRockit 合二为一 存储的数据类型 Class 类型信息，比如Class(com.hero.User类) 方法信息，比如Method(方法名称、方法参数列表、方法返回值信息) 字段信息，比如Field(字段类型，字段名称需要特殊设置才能保存的住) 类变量(静态变量):JDK1.7之后，转移到堆中存储 方法表(方法调用的时候) 在A类的main方法中去调用B类的method1方法，是根据B类的方法表去查找合适的方法，进行调用的 运行时常量池(字符串常量池)从class中的常量池加载而来，JDK1.7之后，转移到堆中存储 字面量类型 引用类型-->内存地址 JIT编译器编译之后的代码缓存 3.7 字符串常量池 三种常量池 Class 常量池 静态常量池 运行时常量池 在方法区 字符传常量池 在堆中 字面量：int、float、long、double、双引号字符传等 符号引用：Class、Method、Field等 字符串常量池如何保存数据 为了加快数据查找的速度 使用 StringTable 的数据结构存储保存字符串的引用 StringTable类似于HashTable(哈希表)，哈希表本质上是一个数组 key：散列函数，公式：hash(字符串)%数组size value：字符串引用 size：-XX:StringTableSize=65536 字符传常量池如何查找数据 根据字符串的hashcode找到对应entry 如果没有冲突，它可能只是一个entry 如何有冲突，它可能是一个entry的链表，然后Java再遍历链表，匹配引用对应的字符串 如果找到字符串，返回引用 如果找不到字符串，在使用intern()方法的时候，会将intern()方法调用者的引用放入到stringtable中 不同字符串相同 hash 案例 public class StringHashCode { public static void main(String[] args) { System.out.println(\"hello\".hashCode());// 99162322 System.out.println(\"world\".hashCode());// 113318802 System.out.println(\"java\".hashCode());// 3254818 System.out.println(\"通话\".hashCode());// 1179395 System.out.println(\"重地\".hashCode());// 1179395 HashMap map = new HashMap<>(); // 99162322 哈希碰撞，数值不存在，则计算哈希，存入数据，若哈希所在位置已有元素，则存入同位置的链表 map.put(\"hello\", 53); // 113318802 哈希碰撞，数值不存在，则计算哈希，存入数据，若哈希所在位置已有元素，则存入同位置的链表 map.put(\"world\", 35); // 3254818 哈希碰撞，数值不存在，则计算哈希，存入数据，若哈希所在位置已有元素，则存入同位置的链表 map.put(\"java\", 55); // 113318802 哈希碰撞，数值存在，则比较字符传的值，字符串值相同，则覆盖元数据 map.put(\"world\", 52); // 1179395 哈希碰撞，数值不存在，则计算哈希，存入数据，若哈希所在位置已有元素，则存入同位置的链表 map.put(\"通话\", 51); // 1179395 哈希碰撞，数值存在，则比较字符传的值，字符串值不相同，则计算哈希，存入数据，若哈希所在位置已有元素，则存入同位置的链表 map.put(\"重地\", 55); System.out.println(map); } } String 比较结果案例 public class StringCompare { public static void main(String[] args) { // str1 在字符传常量池，str2 在堆里 ==比较引用地址 String str1 = \"abc\"; String str2 = new String(\"abc\"); System.out.println(\"case1:\" + (str1 == str2));// false // str3 在堆里，但与 str2 是两个对象，==比较引用地址 String str3 = new String(\"abc\"); System.out.println(\"case2:\" + (str3 == str2));// false // str4 在编译器合并，并放入字符串常量池 String str4 = \"a\" + \"b\"; System.out.println(\"case3:\" + (str4 == \"ab\"));// true // str5 编译器合并，并放入字符串常量池 final String s = \"a\"; String str5 = s + \"b\"; System.out.println(\"case4:\" + (str5 == \"ab\"));// true // str6 在运行时创建，在堆中 String s1 = \"a\"; String s2 = \"b\"; String str6 = s1 + s2; System.out.println(\"case5:\" + (str6 == \"ab\"));// false // str7 在运行时创建，在堆中 String str7 = \"abc\".substring(0, 2); System.out.println(\"case6:\" + (str7 == \"ab\"));// false // str8 在运行时创建，在堆中 String str8 = \"abc\".toUpperCase(); System.out.println(\"case7:\" + (str8 == \"ABC\"));// false // 当调用 intern 方法时，如果常量池中已经该字符串，则返回池中的字符串 // 否则将此字符串添加到常量池中，并返回字符串的引用 String s5 = \"a\"; String s6 = \"abc\"; String s7 = s5 + \"bc\"; System.out.println(\"case8:\" + (s6 == s7.intern()));// true } } 3.8 直接内存 堆外内存，不属于运行时数据区，受本机总内存大小限制 使用场景 有很大的数据需要存储，它的生命周期很长 适合频繁的 IO 操作，例如网络并发场景 堆内存与直接内存分配与读写性能比较案例 public class DirectMemoryCompare { public static void main(String[] args) { // 分配内存 allocateCompare(); //分配比较 // 读写内存 operateCompare(); //读写比较 } /** * 直接内存 和 堆内存的 分配空间比较 * 结论： 在数据量提升时，直接内存相比非直接内的申请，有很严重的性能问题 */ public static void allocateCompare() { int time = 1000 * 10000; //操作次数,1千万 long st = System.currentTimeMillis(); for (int i = 0; i 结论：读写效率高，分配空间性能差 执行结果 分析原因 非直接内存作用链:本地IO –>直接内存–>非直接内存–>直接内存–>本地IO 直接内存作用链:本地IO–>直接内存–>本地IO powered by Gitbook修订时间： 2022-10-03 13:34:09 "},"markdown/01-java/jvm-04.html":{"url":"markdown/01-java/jvm-04.html","title":"4.对象的创建过程与内存分配","keywords":"","body":"4.1 整体过程 4.2 对象内存分配的方式 指针碰撞 Bump the Pointer GC 不带压缩功能 内存地址是连续（新生代） serial 收集器，parNew 收集器等 空闲列表 Free List GC 带压缩功能 内存地址不连续（老年代） CMS 收集器，Mark-Sweep 收集器 4.3 对象内存分配的安全问题 在分配内存的时候，虚拟机给A线程分配内存过程中，指针未修改。此时B线程同时使用了同样一块内存。是不是就出现了线程的安全性问题 解决方案：给对象分配内存时，首先进行TLAB的分配。当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用CAS进行内存分配 4.4 对象内存分配的过程 分配流程 内存分配过程可视化案例 执行如下程序，在 VisualVM 中的观察动态效果 public class HeapMemoryAllocation { public static void main(String[] args) throws InterruptedException { List list = new ArrayList<>(); while (true) { list.add(new byte[1024 * 1024]); Thread.sleep(20); } } } 进入老年代的时机 年龄大，经过 15 次 MinorGC 可通过 -XX:MaxTenuringThreshold 指定 动态年龄判断 MinorGC 之后，发现 Survivor 区中年龄分别为年龄1+年龄2+年龄n的多个对象，对象总和大小超过了 Survivor 区域的50%，此时就会把年龄 n 及以上的对象都放入老年代。 可通过 -XX:TargetSurvivorRatio可以指定比例 大对象直接进入老年代 避免大对象在Eden和Survivor区的复制操作降低效率 可通过 -XX:PretenureSizeThreshold 指定，默认超过 1M 为大对象 大对象创建直接进入老年代案例 public class BigObjectCreate { public static void main(String[] args) throws InterruptedException { byte[] buffer = new byte[1024 * 1024 * 20]; Thread.sleep(1000 * 60 * 60); } } 运行参数：-Xmx60m -Xms60m -XX:NewRatio=2 -XX:SurvivorRatio=8 结果观察 MinorGC 后存活对象太多，无法放入 Survivor 老年代的内存担保 当新生代无法分配内存的时候，将新生代的对象转移到老年代，然后把新对象放入腾空的新生代 内存担保案例 public class MemoryAllocationGuarantee { private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws InterruptedException { byte[] allocation1, allocation2, allocation3, allocation4; allocation1 = new byte[1 * _1MB];//1M allocation2 = new byte[1 * _1MB];//1M allocation3 = new byte[1 * _1MB];//1M allocation4 = new byte[6 * _1MB];//6M } } 结论：三个 1M 的对象进入老年代 4.5 对象的内存布局 对象的内存布局划分 对象头(Header): Java对象头占8byte。如果是数组则占12byte。因为JVM里数组size需要使用4byte存储。 标记字段MarkWord: 用于存储对象自身的运行时数据，它是synchronized实现轻量级锁和偏向锁的关键。 默认存储:对象HashCode、GC分代年龄、锁状态等等信息。 为了节省空间，也会随着锁标志位的变化，存储数据发生变化。下面画图解释 类型指针KlassPoint: 是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例 开启指针压缩存储空间4byte，不开启8byte。JDK1.6+默认开启 数组长度:如果对象是数组，则记录数组长度，占4个byte，如果对象不是数组则不存在。 对齐填充:保证数组的大小永远是8byte的整数倍。 实例数据(Instance Data):生成对象的时候，对象的非静态成员变量也会存入堆空间 对齐填充(Padding):JVM内对象都采用8byte对齐，不够8byte的会自动补齐。 对象头详解 基本数据类型和包装类的内存占用情况 打印空对象的内存布局信息案例 需要引入依赖 org.openjdk.jol jol-core 0.9 执行代码 public class ObjectMemoryPrint { public static void main(String[] args) { Object o = new Object(); System.out.println(\"new Object:\" + ClassLayout.parseInstance(o).toPrintable()); } @Data @Builder static class People{ private boolean adult; private int age; private String name; } } 执行结果 指针压缩默认开启 关闭指针压缩：-XX:-UseCompressedOops 打印空对象和赋值后的对象内存布局信息案例 执行代码 public class ObjectMemoryPrint { public static void main(String[] args) { System.out.println(ClassLayout.parseInstance(People.builder().build()).toPrintable()); System.out.println(ClassLayout.parseInstance(People.builder() .age(18) .name(\"Tom\") .adult(true) .build()).toPrintable()); } @Data @Builder static class People{ private boolean adult; private int age; private String name; } } 执行结果 结论：示例数据是否赋值不影响占用空间大小 4.6 对象的访问 通过句柄访问对象 通过直接指针访问对象 powered by Gitbook修订时间： 2022-12-04 20:50:10 "},"markdown/01-java/concurrent.html":{"url":"markdown/01-java/concurrent.html","title":"多线程与并发编程","keywords":"","body":"powered by Gitbook修订时间： 2022-09-10 23:42:33 "},"markdown/01-java/socket.html":{"url":"markdown/01-java/socket.html","title":"网络编程","keywords":"","body":"powered by Gitbook修订时间： 2022-10-08 09:44:35 "},"markdown/02-database/mysql.html":{"url":"markdown/02-database/mysql.html","title":"MySQL 进阶","keywords":"","body":" MySQL 版本 5.7.30 查看版本号 mysql> select version(); +-----------+ | version() | +-----------+ | 5.7.39 | +-----------+ 1 row in set (0.00 sec) powered by Gitbook修订时间： 2022-10-18 20:29:35 "},"markdown/02-database/store.html":{"url":"markdown/02-database/store.html","title":"海量数据存储与优化","keywords":"","body":"powered by Gitbook修订时间： 2022-09-26 14:56:57 "},"markdown/02-database/mongodb.html":{"url":"markdown/02-database/mongodb.html","title":"MongoDB","keywords":"","body":"powered by Gitbook修订时间： 2022-09-26 14:57:49 "},"markdown/02-database/fastdfs.html":{"url":"markdown/02-database/fastdfs.html","title":"FastDFS","keywords":"","body":"powered by Gitbook修订时间： 2022-09-26 14:56:50 "}}