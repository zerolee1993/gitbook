{"./":{"url":"./","title":"介绍","keywords":"","body":"个人博客地址 http://www.lishaofei.com Gitbook 地址 http://www.lishaofei.com/gitbook Copyright © Zerolee 2019 all right reserved，powered by Gitbook修订时间： 2019-07-05 11:02:16 "},"markdown/java/java-core-36/01.html":{"url":"markdown/java/java-core-36/01.html","title":"理解 Java 平台","keywords":"","body":"理解 Java 平台 1. Java最显著的两个特性 Write once, Run anywhere 跨平台能力 Garbage Collector 垃圾回收 2. JDK JRE 的区别 Java Runtime Environment: Java运行时环境，包含 JVM 和 Java 类库及一些模块 Java Development Kit: JRE 的超集，提供如编译器、诊断工具等额外工具 3. Java 是否是解释执行 不太准确 Java 代码首先通过 javac 编译成字节码，运行时由 JVM 内嵌解释器解释为机器码执行，属于解释执行 但大多数情况我们使用的 JVM 能够在运行时讲热点代码编译成机器码，这部分热点代码就属于编译执行 JDK9 引入 AOT 特性，直接将字节码编译成机器代码，使用 jaotc 命令 Copyright © Zerolee 2019 all right reserved，powered by Gitbook修订时间： 2019-05-22 17:50:48 "},"markdown/java/java-core-36/02.html":{"url":"markdown/java/java-core-36/02.html","title":"异常处理机制","keywords":"","body":"异常处理机制 1. Exception 和 Error 的区别 Java 中只有 Throwable 类型的实例可以被抛出或捕获，它是异常处理的基本组成类型 Exception 和 Error 都继承了 Throwable Exception 属于程序正常运行中可以预料的异常情况，应该被捕获并进行相应处理 Error 一般会导致程序处于非正常不可恢复的状态码，不便于也不需要被捕获，比如 OutOfMemoryError 2. Exception 分类 分为可检查异常 checked 和不可检查异常 unchecked 可检查异常必须进行显式捕获处理，在编译器会检查 不可检查异常就是运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException，通常是编码可避免的逻辑错误，不会再编译器强制要求捕获 有哪些常见的异常？ NoClassDefFoundError 和 ClassNotFoundException 的区别 ClassNotFoundException发生在装入阶段。当应用程序试图通过类的字符串名称，使用常规的三种方法装入类，但却找不到指定名称的类定义时就抛出该异常。 NoClassDefFoundError： 当目前执行的类已经编译，但是找不到它的定义时，也就是说你如果编译了一个类 B ，在类 A 中调用，编译完成以后，你又删除掉 B ，运行 A 的时候那么就会出现这个错误 3. 开发过程需要注意的点 try-with-resources 和 multiple catch 的使用 try-with-resources 在编译时期，会自动生成相应的处理逻辑，比如，自动按照约定俗成close 那些扩展了AutoCloseable 或者 Closeable 的对象 try (BufferedReader br = new BufferedReader(…); BufferedWriter writer = new BufferedWriter(…)) { ... } catch ( IOException | XEception e) { ... } 尽量不要 catch 类似 Exception 这样的通用异常，捕获特定异常 不要生吞异常 不要通过e.printStackTrace()来打印异常 异常输出要脱敏 try-catch 会产生额外的性能开销，影响 JVM 对代码的优化，所以 try 尽可能少的代码段 不要将 try-catch 用于流程控制，使用 if/else/switch 更高效 Java 每实例化一个 Exception 都会对当时的栈进行快照，尽量不要在循环中使用 try-catch Copyright © Zerolee 2019 all right reserved，powered by Gitbook修订时间： 2019-05-29 11:23:43 "},"markdown/java/java-core-36/03.html":{"url":"markdown/java/java-core-36/03.html","title":"final | finally | finalize","keywords":"","body":"final | finally | finalize 1. final 修饰类表示不可被继承，修饰方法表示不能被重写 overwrite 修饰参数或变量表示只读不可更改，并发编程中有利于减少额外的同步开销 2. finally 用于 try-catch-finally 语句，用于执行关闭资源，释放锁等一定要被执行的语句 java 7 后可使用 try-with-resources 进行资源的关闭 如下的特例 finally 中的语句是不会被执行的 try { System.exit(1); } finally{ System.out.println(“hello world); } 准确的说 final 修饰的变量不是不变的，如下面的代码，idList的引用是不变的，元素却可以更改 final List idList = new ArrayList<>(); idList.add(1); idList.add(2); 如要使用不可变的 list，可使用如下方式，当向初始化后的 list 中 add 元素是会抛出异常 List idList = List.of(1, 2); idList.add(3); 如何实现一个不可变的类？ 将 class 声明为 final 将所有成员变量定义为 private final，不要实现 setter 方法 构造对象，成员变量使用深度拷贝初始化，不要直接赋值 如需要 getter 或其他获取类信息的方法，要使用 copy-on-write 原则，创建私有的 copy 3. finalize 是 Object 类的一个方法，用于保证对象在被垃圾回收前完成特定资源的回收 JVM 进行垃圾回收时，针对实现了 finalize 的类会有额外的处理机制，拖慢垃圾回收，导致大量对象堆积，可能导致 OOM，不推荐使用，且在 Java 9 中已经被标记为废弃 资源用完即显示释放，或者利用资源池来尽量重用，不要利用 finalize 承担资源释放的职责 finalize 会掩盖资源回收的出错信息，生吞了一个 Throwable Java 逐步使用 Cleaner 代替 finalize (TODO Cleaner 详情) Copyright © Zerolee 2019 all right reserved，powered by Gitbook修订时间： 2019-05-22 18:14:53 "},"markdown/java/java-core-36/04.html":{"url":"markdown/java/java-core-36/04.html","title":"引用机制","keywords":"","body":"引用机制 不同引用类型，主要体现的是对象不同的可达性 reachable 状态和对垃圾回收的影响 1. 强引用 Strong Reference 最常见的普通对象引用，强引用指向的对象，不会被垃圾回收 普通对象，超出引用的作用于或显示讲引用赋值为 null，就可以被垃圾回收了 2. 软引用 Soft Reference 让引用的对象不会优先被回收 只有当 JVM 人为内存不足时，在抛出 OutOfMemoryError 前会清除软引用指向的对象 可用于实现缓存 3. 弱引用 Weak Reference 被引用的对象会被正常回收 仅仅是提供了一种获取对象的途径，但对象可能已经被回收了 可用于实现缓存 4. 幻象引用 不能通过该引用访问对象 仅仅提供一种对象被回收后，做某些事情的机制 通常用来做 Post-Mortem 清理机制 （TODO）、Cleaner 机制 可用于监控对象的创建和销毁 5. 引用状态改变关系 6. 如何使用（TODO） Copyright © Zerolee 2019 all right reserved，powered by Gitbook修订时间： 2019-05-31 13:52:48 "},"markdown/mysql/standard/guide.html":{"url":"markdown/mysql/standard/guide.html","title":"快速指引","keywords":"","body":"你想做些什么？ 我想新建一张表 我需要为已有表增加或修改字段 我需要为表建立或删除索引 我需要备份数据 我要修改线上数据 我正在开发业务功能 我想新建一张表 > 建表语句参考 CREATE TABLE `table_name` ( `id` INT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键', `column_name1` TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT 'tinyint 示例', `column_name2` INT UNSIGNED NOT NULL COMMENT 'int 示例', `column_name3` VARCHAR(100) NOT NULL DEFAULT '' COMMENT 'varchar 示例', `column_name4` DECIMAL(16,2) NOT NULL DEFAULT 0.00 COMMENT 'decimal 示例', `column_name5` DATETIME NOT NULL COMMENT 'datetime 示例', `is_deleted` TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '逻辑删除 (1：已删，0：未删)', `gmt_create` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modified` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`id`), UNIQUE KEY `uk_column_name` (`column_name`), KEY `idx_column_name` (`column_name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='表备注'; > 需要注意的事项 参考：建表需要注意什么 参考：如何命名 参考：如何选择列的类型 参考：如何建立索引 我需要为已有表增加或修改字段 > 需要注意的事项 参考：如何命名？ 参考：如何选择列的类型？ 参考：如何建立索引？ 修改字段时，将多个 ALTER 语句合并为一个执行 所有表和字段都要添加注释，修改字段含义或对字段表示的状态追加时，需要及时更新字段注释 我需要为表建立或删除索引 > 建立索引语句参考 ALTER TABLE table_name ADD INDEX idx_column1_column2(`column1`,`column2`); ALTER TABLE table_name ADD UNIQUE uk_column1_column2(`column1`,`column2`); > 删除索引语句参考 ALTER TABLE table_name DROP INDEX idx_xxx; > 需要注意的事项 参考：如何建立索引？ 我需要备份数据 > 备份语句参考 CREATE TABLE bak_table_name_yyyyMMdd LIKE table_name; ALTER TABLE bak_table_name_yyyyMMdd COMMENT 'xxxx备份，请保留至yyyyMMdd'; INSERT INTO bak_table_name_yyyyMMdd SELECT * FROM table_name [WHERE ...]; > 需要注意的事项 备份部分数据时，可以在 INSERT 语句最后增加 WHERE 条件 备份表必须以 bak_ 为前缀，并以 _yyyyMMdd 实时日期为后缀。例如 bak_test01_20190409 最好将备份表更改备注，注明备份原因，及最后保留日期，方便清理 我要修改线上数据 > 需要注意的事项 参考：操作线上数据时需要注意什么？ 我正在开发业务功能 > 需要注意的事项 参考：开发需要注意什么？ Copyright © Zerolee 2019 all right reserved，powered by Gitbook修订时间： 2019-05-13 22:33:07 "},"markdown/mysql/standard/standard-v1.0.html":{"url":"markdown/mysql/standard/standard-v1.0.html","title":"基本规范","keywords":"","body":"建表需要注意什么？ 使用自增 id 作为主键 使用 innodb 引擎 使用统一编码 utf8mb4 尽量将所有列定义为NOT NULL 索引 NULL 列需要额外空间来保存空还是非空，所以要占用更多的空间 进行比较和计算时对于 NULL 值做特别的处理，可能使索引失效 可以使用 0，特殊值，空字符串代替 NULL 所有表和字段都要添加注释，修改字段含义或对字段表示的状态追加时，需要及时更新字段注释 存储业务数据的表，建议不要物理删除，添加字段 is_deleted 进行逻辑删除 尽量避免在表中建立预留字段 预留字段的命名很难做到见名识义 预留字段无法确认存储的数据类型 使用很大的VARCHAR影响表性能 对预留字段类型修改时，会对全表进行锁定 修改字段成本远远大于增加一个字段 适当进行反范式化设计，便于查询和索引优化 字段允许适当冗余，以提高查询性能，但必须考虑数据一致 冗余字段应遵循：不是频繁修改的字段；不是 varchar 超长字段；更不能是 text 字段 正例：商品类目名称使用频率高，字段长度短，名称基本一成不变 可在相关联的表中冗余存储类目名称避免关联查询 尽量做到冷热数据分离，减小表的宽度 MySQL限制每个表最多存储4096列，每行大小不能超过65535个字节 减少磁盘IO，保证热数据的内存缓存命中率 更有效的利用缓存，避免使用SELECT * 这种方式读入无用的冷数据 可以对表进行垂直拆分，将经常一起使用额列放到一个表中 单表行数超过 500 万行或者单表容量超过 2GB ，才推荐进行分库分表 说明：如果预计三年后的数据量根本达不到这个级别，就不要在创建表时就分库分表 500w并不是MySQL数据库的限制，MySQL并不会对单表数据量做限制，限制取决于存储设置和文件系统 可以通过历史数据归档，分库分表等手段来控制 避免在数据库中存储图片、文件等二进制数据 导致物理文件大，影响读取表数据时系统的IO效率 将图片、文件存储到文件服务器中，数据库中仅存储地址信息 如何命名？ 库名与应用名保持一致 特殊字段如四要素需要使用统一命名 字段 命名 字段 命名 姓名 name 身份证号 identity_num 手机号 phone 银行卡号 bank_card_num 表名和字段名，必须使用小写字母或数字，下划线分割，禁止出现数字开头，禁止两个下划线中间只出现数字见名知意，不可超过32字符 MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写，因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝 正例：aliyun_admin，rdc_config，level3_name 反例：AliyunAdmin，rdcConfig，level_3_name 表名不使用复数名词 表名应该仅仅表示表里面的实体内容，不应该表示实体数量 正例：system_user，repay_order 反例：system_users，repay_orders 表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 UNSIGNED TINYINT ( 1表示是，0表示否） 禁止使用 MySQL 保留字，如 desc、range、match、delayed 等（请参考MySQL 官方保留字） 主键索引使用 pk_前缀；唯一索引使用 uk_前缀；普通索引使用 idx_前缀 不同表存储相同数据的列（关联列）的列名和列类型必须完全一致 临时库、表名必须以 bak_ 为前缀，并以 _yyyyMMdd 实时日期为后缀。例如 tmp_test01_20190409 备份库、表必须以 bak_ 为前缀，并以 _yyyyMMdd 实时日期为后缀。例如 bak_test01_20190409 如何选择列的类型？ 字段可以使用多种数据类型时，优先考虑数字类型，其次为日期或二进制类型，最后是字符类型 节约数据库表空间、节约索引存储，更重要的是提升检索速度 正例：level TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '逾期等级' 反例：level VARCHAR(2) NOT NULL DEFAULT '' COMMENT '逾期等级' 整数型选择能符合需求的最短列类型，如果为非负数，必须声明 UNSIGNED 正例：id bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键' 反例：id INT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键' 符合需求指可长期满足，不要因为节省长度影响正常业务 扩展：声明整数类型时，可不指定长度，整数类型的长度是固定的 int(3)中的3仅仅代表显示长度，不会限制存储空间 可搭配zerofill关键字进行零补全，但都是用于终端的显示，不影响实际存储的值 列类型 存储空间 取值范围 signed 取值范围 unsigned tinyint 1字节 -128~127 0~255 smallint 2字节 -32768~32767 0~65535 mediumint 3字节 -8388608~8388607 0~16777215 int 4字节 -2147483648~-2147483647 0~4294967295 bigint 8字节 -9223372036854775808~9223372036854775807 0~18446744073709551615 实数类型使用 DECIMAL，禁止使用 FLOAT 和 DOUBLE float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到错误的结果 若存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储 decimal 占用空间由定义的宽度决定 每4个字节可以存储9个数字，小数点占用一个 禁止使用字符串类型代替日期类型，日期占用空间小，便于查找过滤，有丰富的处理函数 列类型 存储空间 格式 范围 备注 datetime 8字节 YYYY-MM-DD HH:MM:SS[.fraction] 1000-01-01 00:00:00 ~9999-12-31 23:59:59 与时区无关datetime(6)指定6位微秒 timestamp 4字节 YYYY-MM-DD HH:MM:SS[.fraction] 1970-01-01~2038-01-19 受时区影响timestamp(6)指定6位微秒 date 3字节 YYYY-MM-DD 1000-01-01 ~ 9999-12-31 time 3字节 HH:MM:SS[.fraction] -838:59:59 ~ 838:59:59 存储时间点或持续时间time(6)指定6位微秒 使用 TINYINT 代替 ENUM ENUM本身是字符串类型但内部是由整数存储的，最多可以存储65535种不同的枚举值 修改ENUM值需要使用ALTER语句，会导致锁表 ORDER BY操作效率低，需要先转换为字符串才排序 不要使用数值作为ENUM的枚举值，产生混淆 使用 INT UNSIGNED 存储 IPV4 将字符串（15字节）转化为用数字（4字节）存储，节省空间 在存入和读取时使用函数进行转换 SELECT INET_ATON('255.255.255.255'); SELECT INET_NTOA(4294967295); 使用 VARCHAR 时 选择能符合需求的最小长度 VARCHAR(N) 中的 N 表示字符数不是字节数，不预先分配存储空间 符合需求指可长期满足，不要因为节省长度影响正常业务 长度不要超过 5000，如果存储长度大于此值，建议定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率，或将数据存入OSS 使用 VARBINARY 存储大小写敏感的变长字符串，VARBINARY 默认区分⼤小写，没有字符集概念，速度快 如何建立索引？ 1. 索引列的选择 SELECT、UPDATE、DELETE语句的WHERE从句中的列建立索引，多个同时出现的列建立联合索引提高性能 包含在ORDER BY、GROUP BY、DISTINCT中的列建立索引，多个同时出现的列建立联合索引提高性能 多表JOIN的关联列上建立索引 2. 索引列顺序的选择 联合索引中，索引按照从左到右的顺序来使用的 把区分度最高的列放在联合索引的最左侧，区分度最高的就是主键和唯一索引的列 区分度相差不大时，选择字段长度小的放在左侧 区分度相差不大，且字段长度相差也不大时，将使用更频繁的列放在左侧 3. 避免进入如下误区 宁滥勿缺，认为一个查询就需要建一个索引 宁缺勿滥，认为索引会消耗空间、严重拖慢更新和新增速度 抵制惟一索引，认为业务的惟一性一律需要在应用层通过[先查后插]方式解决。 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引 不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的 即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生 在 VARCHAR 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可 一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上 可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定 每张表索引不要超过5个 索引并不是越多越好，索引可以提高效率也可以降低效率 索引可以增加查询效率，但同样也会降低插入和更新的效率 索引过多，也会增加查询优化器选择查询计划的时间，导致查询效率的降低 禁止给表中每一列都建立单独的索引 避免建立冗余索引和重复索引 重复索引如：primary key(id)、index(id)、unique index(id) MySQL中的主键自动建立非空唯一索引 冗余索引如：index(a,b,c)、index(a,b)、index(a) 对于频繁查询优先考虑使用覆盖索引 频繁查询如查询商品库存 覆盖索引指包含了所有查询字段的索引 不仅仅是WHERE从句GROUP BY从句中的列，也包含SELECT查询的列组合 避免InnoDB表进行索引的二次查询 可以把随机IP变为顺序IO加快查询效率 开发需要注意什么？ 避免数据类型的隐式转换，会导致索引失效 反例： SELECT name FROM users WHERE id='111'; 禁止使用 SELECT * 消耗更多的CPU和IP以及网络带宽资源 无法使用覆盖索引 可以减少表结构变更带来的影响 使用 IN 代替 OR in的值不要超过500个 in 操作可以有效的利用索引 不使用反向查询，如 NOT IN 和 NOT LIKE 禁止使用 ORDER BY RAND() 进行随机排序 会把表中所有符合条件的数据装载到内存中进行排序 消耗大量的CPU和IO及内存资源 推荐在程序中获取一个随机值，然后根据随机值从数据库获取数据 禁止在 WHERE 从句中对列进行函数转换和计算 反例： ...WHERE DATE(gmt_create)='20180101'; 正例： ...WHERE gmt_create>='20180101' AND gmt_create 禁止 SQL 中存放业务逻辑 使用用 UNION ALL 代替 UNION UNION ALL不需要对结果集再进⾏行排序 禁止在数据库中存储明文密码 避免使用子查询，可以把子查询优化为 JOIN 操作 子查询的结果集无法使用索引 子查询会产生临时表操作，如果子查询数据量大则严重影响效率 消耗过多的CPU和IO资源 超过三个表禁止 JOIN，需要 JOIN 的字段，数据类型必须绝对一致 多表关联查询时， 保证被关联的字段需要有索引 每join一个表会多占用一部分内存(join_buffer_size控制) 会产生临时表操作，影响查询效率 MySQL最多允许关联61个表，建议不超过5个 超过 100w 行的批量写操作，要分批多次进行操作 大批量写操作可能会造成严重的主从延迟 binlog日志为row格式时会产生大量的日志 避免产生大事务操作，导致阻塞 减少与数据库的交互次数 数据库更适合处理批量操作 合并多个相同操作到一起，可以提高处理效率 合理拆分复杂的大 SQL 为多个小 SQL MySQL中一个SQL只能只用一个CPU计算 SQL拆分后可以通过并行执行来提高处理效率 如果有 ORDER BY 的场景，请注意利用索引的有序性 order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后 避免出现 file_sort 的情况，影响查询性能 正例：where a=? and b=? order by c; ，索引：a_b_c 反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b;，索引a_b无法排序。 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决 禁止在线上数据库做压力测试 禁止从开发环境，测试环境直接连接生产环境数据库 操作线上数据时需要注意什么？ 禁止使用不含有字段列表的 INSERT 语句 UPDATE 少量数据时，先使用 SELECT 将需要更改的数据查出，并在 UPDATE 语句的 WHERE 条件中添加主键限制 UPDATE 大量数据时，先对数据进行备份 禁止单条 SQL 语句同时更新多个表 修改字段时，将多个 ALERT 语句合并为一个执行 若需大批量插入或更新，执行语句很多，建议每隔三四百行添加 SELECT SLEEP(1); 语句 Copyright © Zerolee 2019 all right reserved，powered by Gitbook修订时间： 2019-05-13 22:33:07 "},"markdown/mysql/practice/cheat-sheet.html":{"url":"markdown/mysql/practice/cheat-sheet.html","title":"常用 SQL","keywords":"","body":"信息统计 需要更改 scheme_name 为自己需要统计的数据库名SELECT TABLE_NAME 表名, TABLE_COMMENT 注释, TABLE_ROWS 数据量, INDEX_LENGTH 索引长度, TABLE_COLLATION 编码集, AVG_ROW_LENGTH 平均行长度, DATA_LENGTH 数据长度, MAX_DATA_LENGTH 最大数据长度, DATA_FREE 空间碎片, CREATE_TIME 创建时间 FROM information_schema.`TABLES` WHERE TABLE_SCHEMA='scheme_name' ORDER BY TABLE_ROWS DESC; 需要更改 scheme_name 为自己需要统计的数据库名 默认过滤备份表及临时表，可自行修改 sql 通过 table_name 限制查询的信息SELECT CONCAT(c.TABLE_NAME,'(',t.TABLE_COMMENT,')') as 表, c.COLUMN_NAME as 列, c.COLUMN_COMMENT 注释, c.COLUMN_TYPE 数据类型, c.IS_NULLABLE as 是否可为空, c.COLUMN_DEFAULT as 默认值, c.EXTRA as 额外信息 FROM INFORMATION_SCHEMA.COLUMNS c LEFT JOIN INFORMATION_SCHEMA.TABLES t ON c.TABLE_NAME = t.TABLE_NAME where c.table_schema ='scheme_name' and c.TABLE_NAME not like '%bak%' and c.TABLE_NAME not like '%tmp_%' order by c.TABLE_NAME,c.ORDINAL_POSITION 性能监控 SHOW FULL PROCESSLIST; 详细说明参考实时连接监控和管理 Copyright © Zerolee 2019 all right reserved，powered by Gitbook修订时间： 2019-05-13 22:33:07 "},"markdown/mysql/practice/process-manage.html":{"url":"markdown/mysql/practice/process-manage.html","title":"实时连接监控和管理","keywords":"","body":"应用场景 排查 MySQL 相关问题时，需要查看当前到数据库的连接及状态 查看实时的慢查询 执行某查询后，手动终止此查询 如何查看 MySQL 实时连接 可使用如下命令： SHOW PROCESSLIST; 若执行的 SQL 较长导致查询出的 Info 被截取，可使用如下命令查看全部信息： SHOW FULL PROCESSLIST; 该命令等同于如下命令： SELECT * FROM infomation_scheme.PROCESSLIST 实际上就是查询系统表 infomation_scheme.PROCESSLIST 查询结果说明 SHOW PROCESSLIST;查询出的信息如下： 管理员权限可查看全部，其他用户只能查看当前用户的连接 关于 PROCESSLIST 表的字段说明如下：可参考官方文档 字段 解释 id 连接的唯一标识等同于SHOW PROCESSLIST;命令结果中的 ID 列等同于 performance_schema.threads 表的 processlist_id等同于函数 CONNECTION_ID();的返回结果 user 连接的用户 host 主机信息 db 连接的数据库 command 命令类型 time 时长，单位：秒 state 状态 info 执行的语句 如何结束进行中的连接 可以使用 KILL processlist_id 命令结束指定连接，参考官方文档 processlist_id 就是 SHOW PROCESSLIST 查询结果中的 Id 列 Copyright © Zerolee 2019 all right reserved，powered by Gitbook修订时间： 2019-05-13 22:33:07 "},"markdown/hbase/env.html":{"url":"markdown/hbase/env.html","title":"macOS HBase + Hadoop + Zookeeper 环境搭建","keywords":"","body":"搭建 Hadoop 环境 1. 下载 hadoop wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-3.1.2/hadoop-3.1.2.tar.gz tar -zxvf hadoop-3.1.2.tar.gz 2. 配置 hdfs-site.xml vi hadoop-3.1.2/etc/hadoop/hdfs-site.xml 在默认空的 configuration 节点中添加如下内容 dfs.replication 1 dfs.namenode.name.dir file:/xxx/hadoop-3.1.2/data/namenode dfs.datanode.data.dir file:/xxx/hadoop-3.1.2/data/datanode 属性 说明 dfs.replication hdfs 备份个数，默认为 3 dfs.namenode.name.dir namenode 路径 dfs.datanode.data.dir datanode 路径 3. 配置 core-site.xml vi hadoop-3.1.2/etc/hadoop/core-site.xml 在默认空的 configuration 节点中添加如下内容 hadoop.tmp.dir /xxx/hadoop-3.1.2/data/tmp fs.default.name hdfs://localhost:9999 属性 说明 hadoop.tmp.dir 默认为系统的 /tmp，避免自动清理导致一些问题，建议指定自己的文件夹 fs.default.name hdfs 文件系统的访问地址，在 HBase 的配置中需要通过 hbase.rootdir 属性指向这个路径，以便 HBase 使用 hdfs 的文件系统 4. 配置 jdk 环境变量 vi hadoop-3.1.2/etc/hadoop/hadoop-env.sh 找到文件中如下注释的位置，将 export JAVA_HOME 配置正确，记得确保这条配置不要被注释 # The java implementation to use. By default, this environment # variable is REQUIRED on ALL platforms except OS X! export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home 5. 格式化 hdfs cd hadoop-3.1.2/bin ./hadoop namenode -format 6. 启动和关闭 cd hadoop-3.1.2/sbin ./start-all.sh ./stop-all.sh 7. 相关访问地址 Resource Manager: http://localhost:9870 JobTracker: http://localhost:8088 Specific Node Information: http://localhost:8042 搭建 HBase 环境 1. 下载 wget http://mirror.bit.edu.cn/apache/hbase/2.2.0/hbase-2.2.0-bin.tar.gz tar -zxvf hbase-2.2.0-bin.tar.gz 2. 配置 hbase-env.sh vi hbase-2.2.0/conf/hbase-env.sh 找到文件中如下注释的位置，将 export JAVA_HOME 配置正确，记得确保这条配置不要被注释 # The java implementation to use. Java 1.8+ required. export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home 找到文件中如下属性的位置，设置为 false，系统默认为 true，表示使用 HBase 自带的 Zookeeper，在这里我们使用自建的 Zookeeper，方便排查问题，在之后会演示如何安装对应的 Zookeeper 环境 # Tell HBase whether it should manage it's own instance of ZooKeeper or not. export HBASE_MANAGES_ZK=false 3. 配置 hbase-site.xml vi hbase-2.2.0/conf/hbase-site.xml hbase.rootdir hdfs://localhost:9999/hbase hbase.tmp.dir /xxx/hbase-2.2.0/data/tmp hbase.cluster.distributed true hbase.zookeeper.quorum 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183 hbase.zookeeper.property.dataDir /Users/lishaofei/Environment/hbase-2.2.0/zookeeper zookeeper.znode.parent /hbase/master --> 属性 说明 hbase.rootdir HBase存储文件的地址，使用 Hadoop 中配置的的 HDFS 地址 hbase.tmp.dir 默认为系统的 /tmp，避免自动清理导致一些问题，建议指定自己的文件夹 hbase.cluster.distributed 是否开启分布式集群 hbase.zookeeper.quorum 自建 zookeeper 需设置这个属性，并指定 Zookeeper 的地址 hbase.zookeeper.property.dataDir 使用内置 Zookeeper 时相关文件的存放目录若使用自建 Zookeeper，这个属性不生效，无需配置等同于自建 Zookeeper 的 cfg 配置中的 dataDir 指定目录 zookeeper.znode.parent 在 Zookeeper 中 HBase 相关节点的根目录 注释掉的属性不需要配置 hbase.zookeeper.property.dataDir 由于使用了自建 Zookeeper 所以不用配置 网上一些教程将 zookeeper.znode.parent 设置为 /hbase/master，这样在使用 JavaAPI 的判断表是否存在时将抛出如下异常，原因是默认的 HBase 会在 Zookeeper 下建立节点 /hbase/table/hbase:meta，但是当日加入上述配置时，这个节点就建立为 /hbase/master/table/hbase:meta 导致找不到对应的表元数据 No meta znode available, details=row '123' on table 'hbase:meta' at null 4. 启动，关闭 cd hbase-2.2.0/bin ./start-hbase.sh ./stop-hbase.sh 5. 进入 Hbase Shell 并查看状态 cd hbase-2.2.0/bin ./hbase shell hbase(main):001:0> status 1 active master, 0 backup masters, 1 servers, 0 dead, 2.0000 average load Took 0.4010 seconds 6. 问题处理 出现如下警告请直接忽略 WARN [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable 在 HBase Shell 命令行中执行 status 出现如下错误，到 hadoop/bin 目录下执行 ./hadoop dfsadmin -safemode leave ERROR: org.apache.hadoop.hbase.ipc.ServerNotRunningYetException: Server is not running yet 如下三个问题 HBase 启动后 HMaster 节点自己挂掉 无法使用 Stop 关闭 HBase，jps 查看会留下 HRegionServer 节点没有被关闭 进入 Hbase Shell 执行命令报错 ERROR: KeeperErrorCode = NoNode for /hbase/master； 解决方案 进入 HBase 目录下的 logs 文件夹下，查看 master.log 相关日志定位问题（出现任何问题先查这个） 如果是配置问题，请在更改配置后，重启前，删除 Zookeeper 指定的 dataDir 目录下的 version-2 文件夹、删除 HBase 指定的 tmp 目录的内容再重启 还是解决不了，则：关闭所有 java 进程、清理 Hadoop tmp 文件下的内容、重新格式化HDFS、清理 HBase tmp 目录的内容、删除 Zookeeper 指定的 dataDir 目录下的 version-2 文件夹、删除 HBase 目录下的 logs 文件夹中的所有日志，重启，并观察master.log 自建 zookeeper 伪分布式集群 1. 下载 wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.5.5/apache-zookeeper-3.5.5-bin.tar.gz tar -zxvf apache-zookeeper-3.5.5-bin.tar.gz 2. 伪分布式配置 复制三份配置文件 cd apache-zookeeper-3.5.5-bin/conf cp zoo_sample.cfg zoo1.cfg cp zoo_sample.cfg zoo2.cfg cp zoo_sample.cfg zoo3.cfg 修改 zoo1.cfg 的如下两个属性 dataDir=/xxx/apache-zookeeper-3.5.5-bin/data/zk1 clientPort=2181 修改 zoo2.cfg 的如下两个属性 dataDir=/xxx/apache-zookeeper-3.5.5-bin/data/zk2 clientPort=2182 修改 zoo3.cfg 的如下两个属性 dataDir=/xxx/apache-zookeeper-3.5.5-bin/data/zk3 clientPort=2183 在三个配置文件末尾均加入如下内容 server.1=127.0.0.1:2888:3888 server.2=127.0.0.1:2889:3889 server.3=127.0.0.1:2890:3890 3. 启动和关闭 创建启动/关闭脚本，可以手动一个一个启动，这里只是为了方便操作 cd apache-zookeeper-3.5.5-bin # 创建一键启动脚本 vi start-all.sh # 粘贴如下内容并保存 bin/zkServer.sh start conf/zoo1.cfg bin/zkServer.sh start conf/zoo2.cfg bin/zkServer.sh start conf/zoo3.cfg # 保存后赋权 chmod 777 start-all.sh # 创建一键关闭脚本 vi stop-all.sh # 粘贴如下内容并保存 bin/zkServer.sh stop conf/zoo1.cfg bin/zkServer.sh stop conf/zoo2.cfg bin/zkServer.sh stop conf/zoo3.cfg # 保存后赋权 chmod 777 stop-all.sh 启动/关闭 cd apache-zookeeper-3.5.5-bin ./start-all.sh ./stop-all.sh Copyright © Zerolee 2019 all right reserved，powered by Gitbook修订时间： 2019-07-05 14:53:30 "}}